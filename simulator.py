# simulator.py
# Defines the Simulator class that manages agents and runs the simulation

from typing import List, Dict
from agents import Agent, Wasp, Larvae
from agents import AgentType, WaspRole
import numpy as np
from utils import gaussian_attraction

class Simulator:
    """
    Simulator class that manages a collection of agents and coordinates the simulation.
    Responsible for advancing time, handling agents, and aggregating results.
    """
    def __init__(self):
        """
        Initialize the simulator.

        Attributes:
            currentTime (int): Current time step of the simulation.
            agents (List[Agent]): List of all agents participating in the simulation.
            movementHistory (Dict[str, List[List[int]]]): Dictionary mapping each agent's ID to its movement history.
            gradients (Dict[WaspRole, List[List[float]]]): Dictionary mapping each WaspRole to its gradient values.
            grid (numpy.ndarray): 2D NumPy array representing the grid.
            forage (List[List[int]]): List of all forage points in the simulation.
        """
        self.currentTime: int = 0
        self.agents: List[Agent] = []
        self.movementHistory: Dict[str, List[List[int]]] = {}
        self.gradients = {WaspRole.FEEDER:[],WaspRole.FORAGER:[]}
        self.grid = None
        self.forage = []
    # ---------------------------
    # Core methods
    # ---------------------------

    def step(self) -> None:
        """
        Advance the simulation by one time unit.
        Calls step(t) on each agent.
        """
        for agent in self.agents:
            agent.step(self.currentTime)
        self.currentTime += 1

    def addAgent(self, agent: Agent) -> None:
        """Add a new agent to the simulation."""
        self.agents.append(agent)
        
        # initialize movement history with starting position
        self.movementHistory[agent.id] = [agent.getPosition()]

    def addForage(self, x: int, y: int) -> None:
        """
        Add a foraging location (placeholder).
        """
        self.forage.append(np.array([x,y]))
        

    def removeAgent(self, agent: Agent) -> None:
        """Remove an agent from the simulation."""
        if agent in self.agents:
            self.agents.remove(agent)

    def accumulateGradients(self) -> None:
        """
        Accumulate gradients generated by the larvae for all agents.
        """
        agents = self.agents
        # get larvae
        larvae = [agent for agent in agents if agent.type==AgentType.LARVAE]
        for agent in larvae:
            x0,y0 = agent.getPosition()
            spread = agent.radius
            peak = max(agent.hunger/max(agent.food,0.1),0.1)
            # calculate gradient for larvae
            gradient = gaussian_attraction(self.grid[:,0],self.grid[:,1],x0,y0,spread,peak)
            type = agent.type
            if type == AgentType.LARVAE:
                # accumulate gradients for all type of wasps
                self.gradients[WaspRole.FEEDER]=self.gradients[WaspRole.FEEDER]+gradient
                self.gradients[WaspRole.FORAGER]=self.gradients[WaspRole.FORAGER]+gradient
            
    def aggregateMovements(self) -> Dict[int, List[tuple[int, int]]]:
        """
        Collect movement data for all agents.
        Returns {agent_id: [(x, y), ...]}
        """
        #for agent in self.agents:
        #    self.movementHistory[agent.id].append(agent.getPosition())
        return self.movementHistory

    def aggregateFeedLarvae(self) -> dict:
        """
        Collect all feeding events performed by wasps.
        Returns:
            dict: {wasp_id: [list of larvae fed]}
        """
        result = {}
        for agent in self.agents:
            if isinstance(agent, Wasp):
                result[agent.id] = {}
                for event in agent.storedEvents:
                    if "fed" in event:
                        parts = event.split()
                        if len(parts) >= 3:
                            target = parts[2]
                            result[agent.id][target] = result[agent.id].get(target, 0) + 1
        return result

    def aggregateHungerLarvae(self) -> Dict[int, List[int]]:
        """Collect hunger values for larvae agents."""
        return {a.id: [a.hunger] for a in self.agents if isinstance(a, Larvae)}

    def aggregateHungerWasp(self) -> Dict[int, List[int]]:
        """Collect hunger values for wasp agents."""
        return {a.id: [a.hunger] for a in self.agents if isinstance(a, Wasp)}

    def runSimulation(self, t: int) -> List[Dict]:
        """
        Run the simulation for t steps.
        Returns a list of snapshots (dictionary per step).
        """
        results: List[Dict] = []
        for _ in range(t):
            self.step()
            snapshot = {
                "time": self.currentTime,
                "movements": self.aggregateMovements(),
                "hungerLarvae": self.aggregateHungerLarvae(),
                "hungerWasp": self.aggregateHungerWasp(),
            }
            results.append(snapshot)
        return results
    def verifyNumberAgents(self, min_feeders: int = 1, min_foragers: int = 1, min_larvae: int = 1) -> bool:
        
        """
        Verify if the number of agents meets the minimum requirements
        for the simulation to start.

        Args:
            min_feeders (int, optional): Minimum number of feeder wasps. Defaults to 1.
            min_foragers (int, optional): Minimum number of forager wasps. Defaults to 1.
            min_larvae (int, optional): Minimum number of larvae. Defaults to 1.

        Returns:
            bool: True if the number of agents meets the minimum requirements, False otherwise.
        """

        count_feeders = 0
        count_larvae = 0
        count_foragers = 0
        for agent in self.agents:
            if isinstance(agent, Wasp):
                if agent.role == WaspRole.FEEDER:
                    count_feeders += 1
                elif agent.role == WaspRole.FORAGER:
                    count_foragers += 1
            elif isinstance(agent, Larvae):
                count_larvae += 1

        return count_feeders >= min_feeders and count_foragers >= min_foragers and count_larvae >= min_larvae
    
    def createGrid(self, padding: int = 3):
        
        """
        Create a grid based on agent positions.

        The grid is a 2D NumPy array that spans the range of x and y
        coordinates of all agents in the simulation.

        Initiates the gradients dictionary for each WaspRole as an empty list.

        Args:
            padding (int, optional): Padding value for the grid. Defaults to 3.
            
        """
        positions_dict = {'x': [agent.x for agent in self.agents], 'y': [agent.y for agent in self.agents]}
        xmin = min(positions_dict['x'])
        xmax = max(positions_dict['x'])
        ymin = min(positions_dict['y'])
        ymax = max(positions_dict['y'])
        
        x, y = np.meshgrid(np.arange(xmin-padding, xmax+padding+1), np.arange(ymin-padding, ymax+padding+1))
        self.grid = np.concatenate((x.reshape(-1, 1), y.reshape(-1, 1)), axis=1)
        
        for role in self.gradients:
            self.gradients[role] = np.zeros(self.grid.shape[0])

    def verifyGrid(self):
        """
        Verify if the grid has been initialized correctly for the simulation. The conditions are as follows:

        1. The grid matrix has at least one row.
        2. The grid matrix has two columns.

        Returns:
            bool: True if the grid has been initialized correctly, False otherwise.
        """
        return self.grid.shape[0]>0 and self.grid.shape[1]==2
    
    def verifyForage(self):
        """
        Verify if there are any foraging points in the simulation.

        Returns:
            bool: True if there are any foraging points, False otherwise.
        """
        return len(self.forage)>0

    def verifySimulationConditions(self) -> bool:
        
        """
        Verify if the simulation conditions are valid before running.

        The conditions are as follows:

        1. The number of agents meets the minimum requirements.
        2. The grid has been initialized correctly for the simulation.
        3. There are any foraging points in the simulation.

        Returns:
            bool: True if the simulation conditions are valid, False otherwise.
        """
        num_agents = self.verifyNumberAgents()
        self.createGrid()
        grid_verification = self.verifyGrid()
        forage_verification = self.verifyForage()
        return num_agents and grid_verification and forage_verification

    def runSimulation(self, t: int) -> List[Dict]:
        """
        Run the simulation for t steps.

        The simulation conditions are as follows:

        1. The number of agents meets the minimum requirements.
        2. The grid has been initialized correctly for the simulation.
        3. There are any foraging points in the simulation.

        Returns a report dictionary containing the following information:

        - movements: a dictionary mapping each agent's ID to its movement history.
        - feedLarvae: a dictionary mapping each larvae's ID to its feeding history.
        - hungerLarvae: a dictionary mapping each larvae's ID to its hunger history.
        - hungerWasp: a dictionary mapping each wasp's ID to its hunger history.

        Raises:
            ValueError: If the simulation conditions are not met.
        """
        if not self.verifySimulationConditions():
            raise ValueError("Simulation conditions not met")

        i = 0
        while i < t:
            # Accumulate gradients (placeholder)
            self.accumulateGradients()
            j = 0
            while j < len(self.agents):
                agent = self.agents[j]

                # If the agent is a wasp, perform the following steps
                if isinstance(agent, Wasp):
                    # Get a list of all wasp agents (excluding the current agent)
                    position_wasp = [agent_ for agent_ in self.agents if isinstance(agent_, Wasp) and agent != agent_]

                    # Get the positions of all wasp agents with the role of FORAGER
                    position_foragers = [agent_.getPosition() for agent_ in position_wasp if agent_.role == WaspRole.FORAGER]

                    # Get the positions of all wasp agents (excluding the current agent)
                    position_wasp = [agent.getPosition() for agent in position_wasp]

                    # If the wasp agent is a FORAGER, feel the gradient of the foraging points
                    if agent.role == WaspRole.FORAGER:
                        agent.feelGradient(self.grid,self.gradients,self.forage)
                        # Move the wasp agent based on the gradient
                        agent.step(self.agents,self.forage)
                    # If the wasp agent is a FEEDER, feel the gradient of the larvae and wasp agents
                    elif agent.role == WaspRole.FEEDER:
                        agent.feelGradient(self.grid,self.gradients,foragersPositions=position_foragers)
                        # Move the wasp agent based on the gradient
                        agent.step(self.agents)

                    # Get the current position of the wasp agent
                    current_pos = agent.getPosition()

                    # If the current position is different from the previous position, add it to the movement history
                    if self.movementHistory[agent.id][-1] != current_pos:
                        self.movementHistory[agent.id].append(current_pos)

                # If the agent's food is less than 1, increase its hunger by the hunger rate
                if agent.food<1:
                    agent.hunger += agent.hungerRate
                
                # If the agent's food minus its hunger rate is greater than 0, decrease its food by the hunger rate
                if agent.food-agent.hungerRate>0:
                    agent.food -= agent.hungerRate
                # Otherwise, set its food to 0
                else:
                    agent.food = 0

                j += 1

            # Advance time
            self.currentTime += 1
            i += 1

        # Build report dictionary
        report: Dict = {}
        report["movements"] = self.aggregateMovements()
        report["feedLarvae"] = self.aggregateFeedLarvae()
        report["hungerLarvae"] = self.aggregateHungerLarvae()
        report["hungerWasp"] = self.aggregateHungerWasp()

        return report
