# ===============================================================
# analyze_logs.py
# ---------------------------------------------------------------
# Purpose:
#   Post-simulation analysis and visualization for the agent-simulator project.
#   This script processes agent-level and nest-level CSV logs,
#   computes summary statistics, and generates visualization plots
#   for hunger dynamics, behavioral trends, and coordination efficiency.
#
# Author: Thaewa Tansarn
# Capstone Project — Data Mining & Visualization Module
# ===============================================================
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import glob
import os

# ======================================================================
# Step 0: Ensure output directory exists
# ----------------------------------------------------------------------
# Purpose:
#   Prepare the directory to store all generated analysis outputs
#   (plots, CSV summaries, and additional data-mining results).
# ======================================================================
print("\n[Step 0] Preparing output directory for analysis results...")

OUTPUT_DIR = "../analysis_outputs"
os.makedirs(OUTPUT_DIR, exist_ok=True)

# ======================================================================
# Step 1: Locate the latest simulation logs
# ----------------------------------------------------------------------
# Purpose:
#   Automatically detect and use the most recent simulation logs
#   generated by the main simulator (agent_log_*.csv and nest_log_*.csv).
# ======================================================================
print("\n[Step 1] Locating the latest simulation log files...")

agent_files = sorted(glob.glob(os.path.join("..", "agent_log_*.csv")))
nest_files = sorted(glob.glob(os.path.join("..", "nest_log_*.csv")))

if not agent_files or not nest_files:
    raise FileNotFoundError("No simulation log files found in parent directory.")

agent_path = agent_files[-1]
nest_path = nest_files[-1]

print(f"Using logs:\n  Agent: {agent_path}\n  Nest:  {nest_path}")

# ======================================================================
# Step 2: Load data
# ----------------------------------------------------------------------
# Purpose:
#   Read the selected CSV logs into pandas DataFrames for processing.
# ======================================================================
print("\n[Step 2] Loading CSV logs into DataFrames...")

df_agent = pd.read_csv(agent_path)
df_nest = pd.read_csv(nest_path)

print("\n Loaded successfully!")
print(f"Agent log shape: {df_agent.shape}")
print(f"Nest log shape:  {df_nest.shape}")

# ======================================================================
# Step 3: Quick overview
# ----------------------------------------------------------------------
# Purpose:
#   Display available columns to understand which metrics are logged.
# ======================================================================
print("\n[Step 3] Inspecting available columns...")

print("\nAgent log columns:", df_agent.columns.tolist())
print("Nest log columns:", df_nest.columns.tolist())

# ======================================================================
# Step 4: Hunger Dynamics Over Time
# ----------------------------------------------------------------------
# Purpose:
#   Visualize how hunger levels of forager and feeder wasps evolve
#   throughout the simulation. This reflects energy demand patterns.
# ======================================================================
print("\n[Step 4] Plotting hunger dynamics over time...")

plt.figure(figsize=(10, 6))
plt.plot(df_nest['timestamp'], df_nest['avg_hunger_foragers'], label='Foragers Hunger', color='tab:red')
plt.plot(df_nest['timestamp'], df_nest['avg_hunger_feeders'], label='Feeders Hunger', color='tab:orange')
plt.xlabel("Timestep")
plt.ylabel("Average Hunger Level")
plt.title("Hunger Dynamics Over Time")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "1_hunger_dynamics.png"), dpi=300)
plt.show()
print(" Hunger dynamics plot saved.")

# ======================================================================
# Step 5: Correlation Heatmap
# ----------------------------------------------------------------------
# Purpose:
#   Generate a correlation matrix across all numeric variables
#   to identify potential relationships between nest-level features.
# ======================================================================
print("\n[Step 5] Computing and plotting correlation heatmap...")

numeric_cols = df_nest.select_dtypes('number')
corr = numeric_cols.corr()

plt.figure(figsize=(8, 6))
sns.heatmap(corr, cmap="coolwarm", annot=False)
plt.title("Correlation Heatmap (Nest-level)")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "2_correlation_heatmap.png"), dpi=300)
plt.show()
print(" Correlation heatmap saved.")

# ======================================================================
# Step 6: Summary Statistics
# ----------------------------------------------------------------------
# Purpose:
#   Export descriptive statistics (mean, std, min, max, quartiles)
#   for further analysis or publication tables.
# ======================================================================
print("\n[Step 6] Calculating and exporting summary statistics...")

summary = df_nest.describe()
summary_path = os.path.join(OUTPUT_DIR, "3_nest_summary_stats.csv")
summary.to_csv(summary_path, index=True)
print(f"\n Summary statistics exported to {summary_path}")

# ======================================================================
# Step 7: Moving Average Smoothing
# ----------------------------------------------------------------------
# Purpose:
#   Smooth out short-term fluctuations in hunger values to highlight trends.
#   This helps identify long-term behavioral stabilization or oscillation.
# ======================================================================
print("\n[Step 7] Applying moving average smoothing to hunger levels...")

df_nest["hunger_foragers_smooth"] = df_nest["avg_hunger_foragers"].rolling(window=20).mean()
df_nest["hunger_feeders_smooth"] = df_nest["avg_hunger_feeders"].rolling(window=20).mean()

plt.figure(figsize=(10, 6))
plt.plot(df_nest["timestamp"], df_nest["hunger_foragers_smooth"], label="Foragers (Smoothed)", color="tab:red")
plt.plot(df_nest["timestamp"], df_nest["hunger_feeders_smooth"], label="Feeders (Smoothed)", color="tab:orange")
plt.xlabel("Timestep")
plt.ylabel("Average Hunger (Smoothed)")
plt.title("Hunger Trend (Moving Average = 20)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "4_moving_average.png"), dpi=300)
plt.show()
print(" Moving average plot saved.")

# ======================================================================
# Step 8: Hunger Distribution
# ----------------------------------------------------------------------
# Purpose:
#   Visualize the overall distribution of hunger levels across all timesteps
#   for both foragers and feeders — provides insight into energy imbalance.
# ======================================================================
print("\n[Step 8] Plotting hunger distribution histograms...")

plt.figure(figsize=(8, 5))
sns.histplot(df_nest["avg_hunger_foragers"], color="tab:red", bins=30, label="Foragers", kde=True)
sns.histplot(df_nest["avg_hunger_feeders"], color="tab:orange", bins=30, label="Feeders", kde=True)
plt.xlabel("Average Hunger")
plt.title("Hunger Distribution Across Simulation")
plt.legend()
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "5_hunger_distribution.png"), dpi=300)
plt.show()
print(" Hunger distribution plot saved.")

# ======================================================================
# Step 9: Role Dynamics Over Time
# ----------------------------------------------------------------------
# Purpose:
#   Track how many agents perform each role (Forager, Feeder, Larvae)
#   throughout the simulation to understand division-of-labor shifts.
# ======================================================================
print("\n[Step 9] Analyzing agent role dynamics over time...")

# Detect column used as 'role' substitute
role_col = None
for candidate in ["agent_role", "role"]:
    if candidate in df_agent.columns:
        role_col = candidate
        break

if role_col is None:
    raise KeyError("No role column found in agent log. Expected one of: 'agent_role' or 'role'.")

print(f"Using column '{role_col}' for role grouping.")

# Count number of agents per role at each timestep
role_counts = df_agent.groupby(["timestamp", role_col]).size().unstack(fill_value=0)

if role_counts.empty:
    print(" Role count DataFrame is empty — no roles detected.")
else:
    plt.figure(figsize=(10,6))
    for col in role_counts.columns:
        plt.plot(role_counts.index, role_counts[col], label=str(col))
    plt.xlabel("Timestep")
    plt.ylabel("Agent Count")
    plt.title("Role Counts Over Time")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()

    output_path = os.path.join(OUTPUT_DIR, "6_role_counts_over_time.png")
    plt.savefig(output_path, dpi=300)
    plt.show()
    print(f" Saved role dynamics plot → {output_path}")
    
# ======================================================================
# Step 10: PCA Visualization for Behavioral Correlation
# ----------------------------------------------------------------------
# Purpose:
#   Reduce multi-dimensional behavioral variables into two principal components
#   to visualize correlations and overall colony behavior in 2D space.
# ======================================================================
print("\n[Step 10] Running PCA for multi-variable behavioral correlation...")

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

numeric_cols = df_nest.select_dtypes('number').dropna(axis=1)
X = StandardScaler().fit_transform(numeric_cols)

pca = PCA(n_components=2)
pca_result = pca.fit_transform(X)

#Create DataFrame to show loading of each feature on PC1, PC2
loadings = pd.DataFrame(
    pca.components_.T,
    columns=["PC1", "PC2"],
    index=numeric_cols.columns
)

print("PCA Loadings on step 10:")
print(loadings)

plt.figure(figsize=(8,6))
sc = plt.scatter(
    pca_result[:,0], pca_result[:,1],
    c=df_nest["avg_hunger_foragers"], cmap="coolwarm", s=20, alpha=0.7
)
plt.colorbar(sc, label="Avg Hunger (Foragers)")
plt.title("PCA Projection of Nest-level Behavioral Variables")
plt.xlabel("Principal Component 1")
plt.ylabel("Principal Component 2")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "7_pca_behavioral_map.png"), dpi=300)
plt.show()
plt.close()

print(" PCA plot saved.")

# ======================================================================
# Step 11: Cross-correlation (Hunger → Feeding)
# ----------------------------------------------------------------------
# Purpose:
#   Compute the cross-correlation between forager hunger and feeding events
#   to measure how quickly the colony responds to hunger signals.
# ======================================================================
print("\n[Step 11] Evaluating cross-correlation between hunger and feeding events...")

from scipy.signal import correlate

hunger_series = df_nest["avg_hunger_foragers"] - df_nest["avg_hunger_foragers"].mean()
feeding_series = df_nest["feeding_events"] - df_nest["feeding_events"].mean()

corr = correlate(hunger_series, feeding_series, mode='full')
lags = range(-len(df_nest)+1, len(df_nest))

plt.figure(figsize=(10,6))
plt.plot(lags, corr, color="tab:purple")
plt.title("Cross-correlation: Forager Hunger vs Feeding Events")
plt.xlabel("Lag (timesteps)")
plt.ylabel("Correlation")
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "8_cross_correlation_hunger_vs_feeding.png"), dpi=300)
plt.show()
plt.close()
print(" Cross-correlation analysis completed and saved.")

# ======================================================================
# Step 12: Feeding Efficiency Analysis
# ----------------------------------------------------------------------
# Purpose:
#   Evaluate how effectively the colony converts foraging into feeding.
#   High efficiency means that collected food is quickly distributed to larvae.
# ======================================================================
print("\n[Step 12] Calculating and visualizing feeding efficiency...")

df_nest["feeding_efficiency"] = df_nest["feeding_events"] / (df_nest["foraging_events"] + 1e-6)
plt.figure(figsize=(8,5))
plt.plot(df_nest["timestamp"], df_nest["feeding_efficiency"], color="tab:green")
plt.title("Feeding Efficiency Over Time")
plt.xlabel("Timestep")
plt.ylabel("Efficiency (Feeding / Foraging)")
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "9_feeding_efficiency.png"), dpi=300)
plt.show()
plt.close()
print(" Feeding efficiency plot saved.")

# ======================================================================
# Step 13: Food Balance Trend
# ----------------------------------------------------------------------
# Purpose:
#   Visualize how the total food stored in the nest changes over time.
#   The smoothed line shows whether the system reaches a steady-state or collapses.
# ======================================================================
print("\n[Step 13] Plotting food balance trend over time...")

df_nest["food_balance_smooth"] = df_nest["food_balance_in_nest"].rolling(30).mean()
plt.figure(figsize=(10,6))
plt.plot(df_nest["timestamp"], df_nest["food_balance_in_nest"], alpha=0.4, label="Instant", color="tab:blue")
plt.plot(df_nest["timestamp"], df_nest["food_balance_smooth"], label="Smoothed (window=30)", color="tab:cyan")
plt.title("Food Balance Trend (Instant vs Moving Average)")
plt.xlabel("Timestep")
plt.ylabel("Food in Nest")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "10_food_balance_trend.png"), dpi=300)
plt.show()
plt.close()
print(" Food balance trend plot saved.")

# ======================================================================
# Step 14: Behavioral Clustering (K-Means)
# ----------------------------------------------------------------------
# Purpose:
#   Group simulation timesteps into behavioral states based on hunger,
#   feeding, and food balance. Helps detect transitions such as:
#   - Exploration Phase
#   - Active Feeding Phase
#   - Stabilized/Depletion Phase
# ======================================================================
print("\n[Step 14] Performing K-Means clustering on behavioral metrics...")

from sklearn.cluster import KMeans

features_for_cluster = ["avg_hunger_foragers", "feeding_events", "food_balance_in_nest"]
X_cluster = StandardScaler().fit_transform(df_nest[features_for_cluster].fillna(0))

kmeans = KMeans(n_clusters=3, random_state=42, n_init=10)
df_nest["behavior_state"] = kmeans.fit_predict(X_cluster)

pca_cluster = PCA(n_components=2)
X_pca_cluster = pca_cluster.fit_transform(X_cluster)

loadings = pd.DataFrame(
    pca_cluster.components_.T,
    columns=['PC1', 'PC2'],
    index=features_for_cluster
)

print("\nPCA Loadings for clustering features:")
print(loadings.round(6))

plt.figure(figsize=(8,6))
sns.scatterplot(
    x=pca_result[:,0], y=pca_result[:,1],
    hue=df_nest["behavior_state"], palette="Set2", s=40, alpha=0.8
)
plt.title("Behavioral State Clusters (via K-Means)")
plt.xlabel("Principal Component 1")
plt.ylabel("Principal Component 2")
plt.legend(title="Cluster")
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "11_behavioral_clusters.png"), dpi=300)
plt.show()
plt.close()
print(" Behavioral clustering plot saved.")

# ======================================================================
# Step 15: Pairwise Correlation Plot (Seaborn PairPlot)
# ----------------------------------------------------------------------
# Purpose:
#   Display pairwise relationships between major variables.
#   Useful for identifying nonlinear dependencies or covariation.
# ======================================================================
print("\n[Step 15] Analyzing correlation between hunger and food balance...")

sns.pairplot(
    df_nest[["avg_hunger_foragers", "avg_hunger_feeders", "feeding_events", "food_balance_in_nest"]],
    diag_kind="kde",
    plot_kws=dict(alpha=0.6, s=20)
)
plt.suptitle("Pairwise Correlation of Core Variables", y=1.02)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "12_pairwise_correlation.png"), dpi=300)
plt.show()
plt.close()
print(" Pairwise correlation plot saved.")

# ======================================================================
# Step 16: Response Delay Estimation (Cross-correlation Peak Lag)
# ----------------------------------------------------------------------
# Purpose:
#   Identify the time delay between forager hunger peaks and feeding response.
#   Positive lag → Feeding lags behind hunger (delayed response)
#   Negative lag → Feeding anticipates hunger (proactive behavior)
# ======================================================================
print("\n[Step 16] Estimating feeding response lag based on cross-correlation...")

import numpy as np

lag_max = lags[np.argmax(corr)]
print(f" Peak correlation lag: {lag_max} timesteps")

plt.figure(figsize=(10,6))
plt.plot(lags, corr, color="tab:purple", alpha=0.7)
plt.axvline(lag_max, color='gray', linestyle='--', label=f'Peak Lag = {lag_max}')
plt.title("Cross-correlation: Forager Hunger vs Feeding Events (with Peak Lag)")
plt.xlabel("Lag (timesteps)")
plt.ylabel("Correlation")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.savefig(os.path.join(OUTPUT_DIR, "13_cross_correlation_hunger_vs_feeding_lag.png"), dpi=300)
plt.show()
plt.close()
print(" Cross-correlation lag analysis completed and saved.")


# ======================================================================
# End of Data Mining & Visualization Extension
# ----------------------------------------------------------------------
# All results exported to:
#   ../analysis_outputs/
# Use these plots to interpret behavioral transitions,
#   colony efficiency, and hunger-driven dynamics.
# ======================================================================
print(f"\n All figures saved in '{OUTPUT_DIR}/' successfully.")
